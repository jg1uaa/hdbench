+-----------------------------------------------------------------------+
|                                                                       |
|                            HDBENCH clone                              |
|                                                                       |
|                  Copyright (C) 1999 Yuuki NINOMIYA                    |
|                                                                       |
|                         計測アルゴリズム解説                          |
|                                                                       |
+-----------------------------------------------------------------------+

★はじめに

　この解説よりもソースを見たほうが早いです。


---- CPU ----

◆整数演算 

　Pentium クラスになると大抵の演算は 1 クロックで実行できてしまいます。
パイプラインを考慮すれば実質 1 クロックかかりません。こうなると問題に
なるのがループのオーバーヘッドです。Pentium は loop 命令が非常に遅い
(らしい) ので、演算命令が少ないとオーバーヘッドの割合が高くなってします。
　計測値は 1 秒間あたりの整数演算の計算回数です。HDBENCH clone では
計測値 1 につき以下の演算 (命令) を 100 回ずつ実行します。

かけ算 (imul) x2
割り算 (idiv) x2
引き算 (sub) x2
足し算 (add) x2


◆浮動小数点演算 

　計測値は 1 秒間あたりの浮動小数点演算の計算回数です。HDBENCH clone では
計測値 1 につき以下の演算 (命令) を 100 回ずつ実行します。

かけ算 (fmul) x2
割り算 (fdiv) x2
引き算 (fsub) x2
足し算 (fadd) x2


◆メモリ

　転送元と転送先ということで 2MB ずつメモリを確保し、ダブルワードストリング
転送 (movsd) で 32KB ずつ 64 回転送する、というのを繰り返します。32KB を
転送する毎に計測値は 1 を数え、計測は 3 秒間行われます。
　2MB ずつですので、大容量の 2 次キャッシュを持っていてもおそらく影響は
ないことと思われます。


---- VIDEO ----

◆矩形

　通常の Xlib の描画関数を用いて描きまくります。描画場所はランダム、
矩形の大きさは 50x50 ピクセルです。
　計測値は 1 秒間あたりの描画回数です。


◆円

　矩形と同じく通常の Xlib の描画関数を用いて描きまくります。描画場所は
ランダム、円の大きさは直径 50 ピクセルです。
　計測値は 1 秒間あたりの描画回数です。


◆テキスト

　「-adobe-helvetica-medium-r-*--14-*」を用いてランダムな場所に
「HDBENCH clone」と描きまくります。描画にはマルチバイトに非対応の関数を
使っています。
　計測値は 1 秒間あたりの描画回数です。


◆スクロール

　画面全体を 1 ピクセル下にずらしてコピー。そして Y 座標が 0 のラインに
線を引く、を繰り返すことでスクロールを行います。
　50 ピクセルをスクロール (色が変わる) する毎に計測値は 1 を数えます。
計測は 3 秒間行われるはずなのですが、実際には 6 秒ほど経たないと
割り込みが入りません。かなり計測精度はアヤシイ。


◆IMAGE

　XImage を使って 1000 枚のスプライトを縦横無尽に動かします。
HDBENCH とは異なり、スプライトはただの正方形です。グラデーション付の
円ってのは難しいので・・・。
　計測値は 1 秒あたりの書き換えフレーム数です。


---- DISK ----

◆WRITE

　DRIVE で指定されたパスにテンポラリファイルを作成し、「使用容量」で
指定されたサイズまでシーケンシャルに 512KB ずつ書き込みを行います。
　計測値は 1 秒間の転送バイト数です。


◆READ

　読み込みを計測する前にディスクキャッシュをフラッシュしなくては
なりません。でないとキャッシュから読み込んでしまい、正しく計測できなく
なってしまいます。
　で、どうやってフラッシュするかで悩んだのですが、本家 HDBENCH のかずさん
より「指定サイズのファイルを作る関数 (truncate) を使ってファイルを作成し、
それから読み込めばキャッシュは効かないよ」とのアドバイスをもらいまして、
さっそくその方法でやってみたのですが、Linux のディスクキャッシュが非常に
優秀で、この方法でもキャッシュが効いてしまいました。
　結局、実メモリと同サイズのデータをファイルに書き込むという原始的な
方法でキャッシュをフラッシュするようにしました。計測値はかなりあやしい
かもしれません。

　DRIVE で指定されたパスに作成したテンポラリファイルを「使用容量」で
指定されたサイズまでシーケンシャルに 512KB ずつ読み込みを行います。
　計測値は 1 秒間の転送バイト数です。



★最後に

　ベンチマークはあくまでも参考であり、これが全てではありませんので
ベンチマーク史上主義に陥らないように気をつけてください。


---------------------------
Yuuki NINOMIYA(二之宮 祐樹)

